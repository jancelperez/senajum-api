'use strict';
// ava es para poder realizar los test

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _micro = require('micro');

var _micro2 = _interopRequireDefault(_micro);

var _testListen = require('test-listen');

var _testListen2 = _interopRequireDefault(_testListen);

var _requestPromise = require('request-promise');

var _requestPromise2 = _interopRequireDefault(_requestPromise);

var _pictures = require('../pictures');

var _pictures2 = _interopRequireDefault(_pictures);

var _fixtures = require('./fixtures');

var _fixtures2 = _interopRequireDefault(_fixtures);

var _utils = require('../lib/utils');

var _utils2 = _interopRequireDefault(_utils);

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _avaThrowsHelperStart(t, assertion, file, line) {
  if (t._throwsArgStart) {
    t._throwsArgStart(assertion, file, line);
  }
}

function _avaThrowsHelperEnd(t, arg) {
  if (t._throwsArgEnd) {
    t._throwsArgEnd();
  }

  return arg;
}

// send es el metodo para enviar respuestas


// test-liste es una herramienta que me permite hacer test con microservicios


// request-promise permite hacer http utilizando promesas


// importamos el modulu pictures el cual creamos para el sistema de enrutamiento


_ava2.default.beforeEach(async t => {
  let servidor = (0, _micro2.default)(_pictures2.default);
  t.context.url = await (0, _testListen2.default)(servidor);
});

// GET /id es la primera ruta la cual es un test asincrono
(0, _ava2.default)('GET /:id', async t => {
  // generar un id como si fuera el id de la imagen
  let imagen = _fixtures2.default.getImagen();

  // listen retorna una url con url y puerto con el cual el servidor esta corriendo el puerto lo crea listen
  // listenn retorna una promesa
  let url = t.context.url;

  // hacer la peticion http diciendo que nos devuelva los datos en json
  let body = await (0, _requestPromise2.default)({ uri: `${url}/${imagen.publicId}`, json: true });

  // con deepEquual validar que la imagen que tubo de esa ruta (body) es igual al objeto que obtiene de getImagen()
  t.deepEqual(body, imagen);
});

// POST / es la segunda ruta la cual es un test asincrono
(0, _ava2.default)('no token POST /', async t => {
  let imagen = _fixtures2.default.getImagen();
  let url = t.context.url;

  let options = {
    method: 'POST',
    url: url,
    json: true,
    body: {
      description: imagen.description,
      src: imagen.src,
      UserId: imagen.userId
    },
    resolveWithFullResponse: true
  };

  let response = await (0, _requestPromise2.default)(options);

  // t.is(response.statusCode, 201)
  // t.deepEqual(response.body, imagen)
  t.throws((_avaThrowsHelperStart(t, 'throws', 'C:/xampp/htdocs/SENAJUM/senagram-api/test/pictures-test.js', 65), _avaThrowsHelperEnd(t, response)), /invalid token/);
});

// POST / es la segunda ruta la cual es un test asincrono
(0, _ava2.default)('secure POST /', async t => {
  let imagen = _fixtures2.default.getImagen();
  let url = t.context.url;
  let token = await _utils2.default.iniciarToken({ userId: imagen.userId }, _config2.default.secret);

  let options = {
    method: 'POST',
    url: url,
    json: true,
    body: {
      description: imagen.description,
      src: imagen.src,
      UserId: imagen.userId
    },
    headers: {
      'Authorization': `Bearer ${token}`
    },
    resolveWithFullResponse: true
  };

  let response = await (0, _requestPromise2.default)(options);

  t.is(response.statusCode, 201);
  t.deepEqual(response.body, imagen);
});

// POST /id/ like es para la ruta que nos va a dar los like de la aplicacion
(0, _ava2.default)('POST /:id /like', async t => {
  let imagen = _fixtures2.default.getImagen();
  let url = t.context.url;

  let options = {
    method: 'POST',
    uri: `${url}/${imagen.id}/like`,
    json: true

    // me devuelve el objeto con la imagen ya con los likes
  };let body = await (0, _requestPromise2.default)(options);

  // clonar la imagen de arriba volviendo el objeto imagen a un string y luego lo parceamos a JSON
  let NuevaImagen = JSON.parse(JSON.stringify(imagen));
  NuevaImagen.liked = true;
  NuevaImagen.likes = 1;

  t.deepEqual(body, NuevaImagen);
});
// una de las caracteristicas de ava es definir el test sin implementar el test esto lo puedo hacer con todo
(0, _ava2.default)('GET /list', async t => {
  let imagenes = _fixtures2.default.getImagenes();
  let url = t.context.url;

  let options = {
    method: 'GET',
    uri: `${url}/list`,
    json: true
  };

  let body = await (0, _requestPromise2.default)(options);

  t.deepEqual(body, imagenes);
});

(0, _ava2.default)('GET /tag/:tag', async t => {
  let imagenes = _fixtures2.default.getImagenesPorTag();
  let url = t.context.url;

  let options = {
    method: 'GET',
    uri: `${url}/tag/awesome`,
    json: true
  };

  let body = await (0, _requestPromise2.default)(options);

  t.deepEqual(body, imagenes);
});
//# sourceMappingURL=..\node_modules\.cache\ava\95c95aaeac12cb2ca219748eebc411a8.js.map