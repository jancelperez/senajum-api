'use strict';
// ava es para poder realizar los test

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _micro = require('micro');

var _micro2 = _interopRequireDefault(_micro);

var _testListen = require('test-listen');

var _testListen2 = _interopRequireDefault(_testListen);

var _requestPromise = require('request-promise');

var _requestPromise2 = _interopRequireDefault(_requestPromise);

var _pictures = require('../pictures');

var _pictures2 = _interopRequireDefault(_pictures);

var _fixtures = require('./fixtures');

var _fixtures2 = _interopRequireDefault(_fixtures);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// importamos el modulu pictures el cual creamos para el sistema de enrutamiento


// test-liste es una herramienta que me permite hacer test con microservicios
_ava2.default.beforeEach(async t => {
  let servidor = (0, _micro2.default)(_pictures2.default);
  t.context.url = await (0, _testListen2.default)(servidor);
});

// GET /id es la primera ruta la cual es un test asincrono


// request-promise permite hacer http utilizando promesas


// send es el metodo para enviar respuestas
(0, _ava2.default)('GET /:id', async t => {
  // generar un id como si fuera el id de la imagen
  let imagen = _fixtures2.default.getImagen();

  // listen retorna una url con url y puerto con el cual el servidor esta corriendo el puerto lo crea listen
  // listenn retorna una promesa
  let url = t.context.url;

  // hacer la peticion http diciendo que nos devuelva los datos en json
  let body = await (0, _requestPromise2.default)({ uri: `${url}/${imagen.publicId}`, json: true });

  // con deepEquual validar que la imagen que tubo de esa ruta (body) es igual al objeto que obtiene de getImagen()
  t.deepEqual(body, imagen);

  console.log(`${url}/${imagen.publicId} esto es una prueba`);
});

// POST / es la segunda ruta la cual es un test asincrono
(0, _ava2.default)('POST /', async t => {
  let imagen = _fixtures2.default.getImagen();
  let url = t.context.url;

  let options = {
    method: 'POST',
    url: url,
    json: true,
    body: {
      description: imagen.description,
      src: imagen.src,
      UserId: imagen.userId
    },
    resolveWithFullResponse: true
  };

  let response = await (0, _requestPromise2.default)(options);

  t.is(response.statusCode, 201);
  t.deepEqual(response.body, imagen);
});

// POST /id/ like es para la ruta que nos va a dar los like de la aplicacion
(0, _ava2.default)('POST /:id /like', async t => {
  let imagen = _fixtures2.default.getImagen();
  let url = t.context.url;

  let options = {
    method: 'POST',
    uri: `${url}/${imagen.id}/like`,
    json: true

    // me devuelve el objeto con la imagen ya con los likes
  };let body = await (0, _requestPromise2.default)(options);

  // clonar la imagen de arriba volviendo el objeto imagen a un string y luego lo parceamos a JSON
  let NuevaImagen = JSON.parse(JSON.stringify(imagen));
  NuevaImagen.liked = true;
  NuevaImagen.likes = 1;

  t.deepEqual(body, NuevaImagen);
});
// una de las caracteristicas de ava es definir el test sin implementar el test esto lo puedo hacer con todo
(0, _ava2.default)('GET /list', async t => {
  let imagenes = _fixtures2.default.getImagenes();
  let url = t.context.url;

  let options = {
    method: 'GET',
    uri: `${url}/list`,
    json: true
  };

  let body = await (0, _requestPromise2.default)(options);

  t.deepEqual(body, imagenes);
});

(0, _ava2.default)('GET /tag/:tag', async t => {
  // let imagenes = fixtures.getImagenesPorTag()
  let url = t.context.url;

  let options = {
    method: 'GET',
    uri: `${url}/tag/awesome/`,
    json: true
  };

  let body = await (0, _requestPromise2.default)(options);

  t.deepEqual(body, body);
});
//# sourceMappingURL=..\node_modules\.cache\ava\cbd7ce10fff7ff0a35488d758667bf85.js.map