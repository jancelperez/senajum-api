{"version":3,"sources":["pictures-test.js"],"names":["beforeEach","t","servidor","context","url","imagen","getImagen","body","uri","publicId","json","deepEqual","options","method","description","src","UserId","userId","resolveWithFullResponse","throws","token","iniciarToken","secret","headers","response","is","statusCode","id","NuevaImagen","JSON","parse","stringify","liked","likes","imagenes","getImagenes","getImagenesPorTag"],"mappings":"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","file":"pictures-test.js","sourcesContent":["'use strict'\r\n// ava es para poder realizar los test\r\nimport test from 'ava'\r\n\r\n// send es el metodo para enviar respuestas\r\nimport micro from 'micro'\r\n\r\n// test-liste es una herramienta que me permite hacer test con microservicios\r\nimport listen from 'test-listen'\r\n\r\n// request-promise permite hacer http utilizando promesas\r\nimport request from 'request-promise'\r\n\r\n// importamos el modulu pictures el cual creamos para el sistema de enrutamiento\r\nimport pictures from '../pictures'\r\n\r\nimport fixtures from './fixtures'\r\n\r\nimport utils from '../lib/utils'\r\n\r\nimport config from '../config'\r\n\r\ntest.beforeEach(async t => {\r\n  let servidor = micro(pictures)\r\n  t.context.url = await listen(servidor)\r\n})\r\n\r\n// GET /id es la primera ruta la cual es un test asincrono\r\ntest('GET /:id', async t => {\r\n  // generar un id como si fuera el id de la imagen\r\n  let imagen = fixtures.getImagen()\r\n\r\n  // listen retorna una url con url y puerto con el cual el servidor esta corriendo el puerto lo crea listen\r\n  // listenn retorna una promesa\r\n  let url = t.context.url\r\n\r\n  // hacer la peticion http diciendo que nos devuelva los datos en json\r\n  let body = await request({uri: `${url}/${imagen.publicId}`, json: true})\r\n\r\n  // con deepEquual validar que la imagen que tubo de esa ruta (body) es igual al objeto que obtiene de getImagen()\r\n  t.deepEqual(body, imagen)\r\n})\r\n\r\n// POST / es la segunda ruta la cual es un test asincrono\r\ntest('no token POST /', async t => {\r\n  let imagen = fixtures.getImagen()\r\n  let url = t.context.url\r\n\r\n  let options = {\r\n    method: 'POST',\r\n    url: url,\r\n    json: true,\r\n    body: {\r\n      description: imagen.description,\r\n      src: imagen.src,\r\n      UserId: imagen.userId\r\n    },\r\n    resolveWithFullResponse: true\r\n  }\r\n\r\n  t.throws(request(options), /invalid token/)\r\n})\r\n\r\n// POST / es la segunda ruta la cual es un test asincrono\r\ntest('secure POST /', async t => {\r\n  let imagen = fixtures.getImagen()\r\n  let url = t.context.url\r\n  let token = await utils.iniciarToken({userId: imagen.userId}, config.secret)\r\n\r\n  let options = {\r\n    method: 'POST',\r\n    url: url,\r\n    json: true,\r\n    body: {\r\n      description: imagen.description,\r\n      src: imagen.src,\r\n      UserId: imagen.userId\r\n    },\r\n    headers: {\r\n      'Authorization': `Bearer ${token}`\r\n    },\r\n    resolveWithFullResponse: true\r\n  }\r\n\r\n  let response = await request(options)\r\n\r\n  t.is(response.statusCode, 201)\r\n  t.deepEqual(response.body, imagen)\r\n})\r\n\r\n// POST /id/ like es para la ruta que nos va a dar los like de la aplicacion\r\ntest('POST /:id /like', async t => {\r\n  let imagen = fixtures.getImagen()\r\n  let url = t.context.url\r\n\r\n  let options = {\r\n    method: 'POST',\r\n    uri: `${url}/${imagen.id}/like`,\r\n    json: true\r\n  }\r\n\r\n  // me devuelve el objeto con la imagen ya con los likes\r\n  let body = await request(options)\r\n\r\n  // clonar la imagen de arriba volviendo el objeto imagen a un string y luego lo parceamos a JSON\r\n  let NuevaImagen = JSON.parse(JSON.stringify(imagen))\r\n  NuevaImagen.liked = true\r\n  NuevaImagen.likes = 1\r\n\r\n  t.deepEqual(body, NuevaImagen)\r\n})\r\n// una de las caracteristicas de ava es definir el test sin implementar el test esto lo puedo hacer con todo\r\ntest('GET /list', async t => {\r\n  let imagenes = fixtures.getImagenes()\r\n  let url = t.context.url\r\n\r\n  let options = {\r\n    method: 'GET',\r\n    uri: `${url}/list`,\r\n    json: true\r\n  }\r\n\r\n  let body = await request(options)\r\n\r\n  t.deepEqual(body, imagenes)\r\n})\r\n\r\ntest('GET /tag/:tag', async t => {\r\n  let imagenes = fixtures.getImagenesPorTag()\r\n  let url = t.context.url\r\n\r\n  let options = {\r\n    method: 'GET',\r\n    uri: `${url}/tag/awesome`,\r\n    json: true\r\n  }\r\n\r\n  let body = await request(options)\r\n\r\n  t.deepEqual(body, imagenes)\r\n})\r\n"]}